import React, { FormEvent, useEffect, useMemo, useState } from 'react';
import {
  CalendarClock,
  Sparkles,
  Bot,
} from 'lucide-react';

import JobMatchesView from './components/jobs/JobMatchesView';
import PipelineView from './components/dashboard/PipelineView';
import AppHeader from './components/layout/AppHeader';
import SidebarNavigation from './components/layout/SidebarNavigation';
import PipelineSidebar from './components/pipeline/PipelineSidebar';
import { stageOrder } from './constants/stages';
import type {
  JobFilters,
  JobLead,
  JobPriority,
  JobTask,
  JobTaskWithLead,
  NewJobFormState,
  OutreachTemplate,
  TaskStatus,
} from './types/job';
import type { JobStage } from './constants/stages';
import { cn } from './lib/cn';
import { supabase } from './lib/supabaseClient';
import { useAddJobMatch, useJobMatches, normalizeTasks } from './hooks/useJobMatches';
import { useJobMutations } from './hooks/useJobMutations';
import { useAuth } from './providers/AuthProvider';
import AuthGate from './components/auth/AuthGate';

const createId = () =>
  typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
    ? crypto.randomUUID()
    : `${Date.now()}-${Math.random().toString(16).slice(2)}`;

const fallbackJobs: JobLead[] = [
  {
    id: 'lead-1',
    company: 'Atlas Robotics',
    role: 'Senior AI Product Manager',
    location: 'Remote - US',
    link: 'https://example.com/jobs/atlas-ai-pm',
    priority: 'High',
    stage: 'Interviewing',
    lastTouchpoint: new Date().toISOString(),
    followUpDate: new Date(Date.now() + 1000 * 60 * 60 * 24 * 2).toISOString(),
    automationScore: 82,
    tags: ['AI', 'Product', 'Remote-first'],
    notes: ['Panel interview scheduled Friday', 'Hiring manager loves quant storytelling'],
    description:
      'Lead AI product strategy within an autonomous robotics platform. Partner with research, engineering, and GTM to ship intelligent capabilities.',
  },
  {
    id: 'lead-2',
    company: 'Northwind Labs',
    role: 'Lead Platform Strategist',
    location: 'Austin, TX',
    link: 'https://example.com/jobs/northwind-platform',
    priority: 'Medium',
    stage: 'Applied',
    lastTouchpoint: new Date(Date.now() - 1000 * 60 * 60 * 24 * 2).toISOString(),
    followUpDate: new Date(Date.now() + 1000 * 60 * 60 * 24 * 5).toISOString(),
    automationScore: 74,
    tags: ['Platform', 'Growth'],
    notes: ['Referred by alumni', 'Needs follow-up to recruiter on availability'],
    description:
      'Drive platform adoption and partner integrations, collaborating with enterprise accounts to design activation playbooks and measure product performance.',
  },
  {
    id: 'lead-3',
    company: 'Lighthouse Health',
    role: 'Director of Product Operations',
    location: 'Boston, MA (Hybrid)',
    link: 'https://example.com/jobs/lighthouse-product-ops',
    priority: 'High',
    stage: 'Prospecting',
    lastTouchpoint: new Date(Date.now() - 1000 * 60 * 60 * 24 * 4).toISOString(),
    followUpDate: undefined,
    automationScore: 68,
    tags: ['Healthcare', 'Operations'],
    notes: ['Need warm intro via LinkedIn group', 'Map product suite before outreach'],
    description:
      'Scale product operations across a care delivery platform. Establish rhythms, tooling, and insights that enable product squads to ship faster with higher quality.',
  },
];

const fallbackTasks: JobTask[] = [
  {
    id: 'task-1',
    jobId: 'lead-1',
    title: 'Send thank-you recap & attach roadmap artifact',
    category: 'Follow-up',
    dueDate: new Date(Date.now() + 1000 * 60 * 60 * 12).toISOString(),
    status: 'scheduled',
    autoGenerated: true,
  },
  {
    id: 'task-2',
    jobId: 'lead-2',
    title: 'Automate recruiter follow-up email with metrics',
    category: 'Outreach',
    dueDate: new Date(Date.now() + 1000 * 60 * 60 * 24 * 2).toISOString(),
    status: 'pending',
    autoGenerated: true,
  },
  {
    id: 'task-3',
    jobId: 'lead-3',
    title: 'Build persona map & generate custom outreach sequence',
    category: 'Research',
    dueDate: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(),
    status: 'pending',
    autoGenerated: false,
  },
];

const outreachTemplates: OutreachTemplate[] = [
  {
    id: 'template-1',
    title: 'Discovery Outreach',
    purpose: 'Connect with hiring manager with value-first framing',
    prompt: `Subject: How I can accelerate [COMPANY]'s 2025 roadmap

Hi [NAME],

I've been following [COMPANY]'s progress on [STRATEGIC INITIATIVE]. I recently led a similar initiative that unlocked [RESULT]. Would love to trade notes on how this can translate to your next milestone.

Here's a 90-second loom covering the playbook. Open to a quick sync next week?

Best,
[YOU]`,
    followUpDays: 3,
  },
  {
    id: 'template-2',
    title: 'Post-Interview Recap',
    purpose: 'Send structured summary + automation-ready call to action',
    prompt: `Subject: Key takeaways + next steps

Thanks again for diving deep on [TOPICS]. Based on the conversation I've mapped three quick wins I can deliver in Sprint 1:

1. [IMPACT AREA]
2. [METRIC TO MOVE]
3. [CROSS-FN PARTNER]

Let me know if you want the operational plan I mentioned – I can spin that up tonight.`,
    followUpDays: 2,
  },
  {
    id: 'template-3',
    title: 'Referral Activation',
    purpose: 'Empower champions to open doors',
    prompt: `Subject: Quick intro request

Hey [NAME],

I saw you're connected with [CONTACT] on the [TEAM] at [COMPANY]. I put together a 1-page highlight reel tailored to their priorities. Mind teeing up an intro? Happy to draft a forwardable blurb.

Appreciate you!
[YOU]`,
    followUpDays: 4,
  },
];

const mapStatusToStage = (status: string): JobStage => {
  const normalized = status.toLowerCase();
  if (normalized.includes('apply')) return 'Applied';
  if (normalized.includes('interview')) return 'Interviewing';
  if (normalized.includes('offer')) return 'Offer';
  if (normalized.includes('hire')) return 'Hired';
  if (normalized.includes('arch')) return 'Archived';
  return 'Prospecting';
};

const JobSearchAutomation: React.FC = () => {
  const { status: authStatus, user, signOut } = useAuth();
  const [localJobs, setLocalJobs] = useState<JobLead[]>(fallbackJobs);
  const [localTasks, setLocalTasks] = useState<JobTask[]>(fallbackTasks);
  const [selectedJobId, setSelectedJobId] = useState<string>(fallbackJobs[0]?.id ?? '');
  const [filters, setFilters] = useState<JobFilters>({ search: '', stage: 'all', priority: 'all' });
  const [sortBy, setSortBy] = useState<'newest' | 'best'>('newest');
  const [activeTab, setActiveTab] = useState<'matches' | 'applying' | 'applied'>('matches');
  const [newJob, setNewJob] = useState<NewJobFormState>({
    company: '',
    role: '',
    location: '',
    link: '',
    priority: 'Medium',
    tags: '',
  });
  const [isMobileNavOpen, setIsMobileNavOpen] = useState(false);

  const matchesQuery = useJobMatches();
  const addJobMutation = useAddJobMatch();
  const { updateStage, updateTaskStatus, scheduleFollowUp } = useJobMutations();
  
  const supabaseEnabled = Boolean(supabase);
  const isRemote = supabaseEnabled && authStatus === 'signed-in';

  const remoteMatches = isRemote ? matchesQuery.data ?? [] : [];
  const remoteJobs: JobLead[] = remoteMatches.map((match) => ({
    id: match.id,
    company: match.job_postings.company,
    role: match.job_postings.role,
    location: match.job_postings.location ?? 'Remote',
    link: match.job_postings.url ?? '',
    priority: (match.priority.charAt(0).toUpperCase() + match.priority.slice(1).toLowerCase()) as JobPriority,
    stage: mapStatusToStage(match.status),
    lastTouchpoint: match.last_touchpoint ?? new Date().toISOString(),
    followUpDate: match.follow_up_at ?? undefined,
    automationScore: match.fit_score ?? 70,
    tags: match.tags ?? [],
    notes: match.notes ?? [],
    description: match.job_postings.description ?? undefined,
  }));

  const remoteTasks = isRemote ? normalizeTasks(remoteMatches) : [];

  const jobs = isRemote && remoteJobs.length ? remoteJobs : localJobs;
  const localTasksWithJob: JobTaskWithLead[] = localTasks.map((task) => ({
    ...task,
    job: localJobs.find((job) => job.id === task.jobId),
  }));
  const tasks: JobTaskWithLead[] = isRemote && remoteTasks.length ? remoteTasks : localTasksWithJob;

  const filteredJobs = useMemo(() => {
    const filtered = jobs.filter((job) => {
      const matchesSearch = `${job.company} ${job.role} ${job.location}`
        .toLowerCase()
        .includes(filters.search.toLowerCase());
      const matchesStage = filters.stage === 'all' || job.stage === filters.stage;
      const matchesPriority = filters.priority === 'all' || job.priority === filters.priority;
      return matchesSearch && matchesStage && matchesPriority;
    });

    return filtered.sort((a, b) => {
      if (sortBy === 'best') {
        return b.automationScore - a.automationScore;
      }
      return new Date(b.lastTouchpoint).getTime() - new Date(a.lastTouchpoint).getTime();
    });
  }, [filters, jobs, sortBy]);

  const selectedJob = jobs.find((job) => job.id === selectedJobId) ?? filteredJobs[0] ?? null;

  useEffect(() => {
    if (!filteredJobs.length) return;
    const stillVisible = filteredJobs.some((job) => job.id === selectedJobId);
    if (!stillVisible) {
      setSelectedJobId(filteredJobs[0].id);
    }
  }, [filteredJobs, selectedJobId]);

  const pipelineMetrics = useMemo(() => {
    const stageCounts = stageOrder.reduce<Record<JobStage, number>>((acc, stage) => {
      acc[stage] = jobs.filter((job) => job.stage === stage).length;
      return acc;
    }, {} as Record<JobStage, number>);

    const activeLeads = jobs.filter((job) => job.stage !== 'Archived').length;
    const automationAverage = Math.round(
      jobs.reduce((total, job) => total + job.automationScore, 0) / (jobs.length || 1),
    );
    const upcomingFollowUps = tasks.filter((task) => task.status !== 'completed').length;

    return {
      stageCounts,
      activeLeads,
      automationAverage,
      upcomingFollowUps,
    };
  }, [jobs, tasks]);

  const jobTasks = useMemo(
    () => (selectedJob ? tasks.filter((task) => task.jobId === selectedJob.id) : []),
    [selectedJob, tasks],
  );

  const nextFollowUps = useMemo<JobTaskWithLead[]>(() => {
    return tasks
      .filter((task) => task.status !== 'completed')
      .sort((a, b) => new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime())
      .slice(0, 5)
      .map((task) => ({
        ...task,
        job: jobs.find((job) => job.id === task.jobId),
      }));
  }, [jobs, tasks]);

  const automationIdeas = useMemo(() => {
    const prospectingCount = jobs.filter((job) => job.stage === 'Prospecting').length;
    const agingApplications = jobs.filter(
      (job) => job.stage === 'Applied' && Date.now() - new Date(job.lastTouchpoint).getTime() > 1000 * 60 * 60 * 24 * 3,
    ).length;
    const interviewPrep = jobs.filter((job) => job.stage === 'Interviewing').length;

    return [
      {
        id: 'idea-1',
        title: 'Weekly Outreach Sprint',
        description: `Queue ${prospectingCount + 2} targeted messages based on your ICP tags automatically.`,
        icon: Bot,
        emphasis: 'automation',
      },
      {
        id: 'idea-2',
        title: 'Follow-up Cadence Guardrails',
        description: `${agingApplications} applications are ready for a recruiter bump. Generate touchpoints + add calendar reminders in one click.`,
        icon: CalendarClock,
        emphasis: 'cadence',
      },
      {
        id: 'idea-3',
        title: 'Interview Readiness Pack',
        description: `${interviewPrep} pipeline conversations flagged for prep. Spin up question banks, stories, and STAR cheat sheets.`,
        icon: Sparkles,
        emphasis: 'prep',
      },
    ];
  }, [jobs]);

  const isLoadingMatches = isRemote && matchesQuery.isLoading;
  const isErrorMatches = isRemote && matchesQuery.isError;

  const handleStageChange = (jobId: string, stage: JobStage) => {
    if (isRemote) {
      updateStage.mutate({ matchId: jobId, stage });
      return;
    }

    setLocalJobs((prev) =>
      prev.map((job) =>
        job.id === jobId
          ? {
              ...job,
              stage,
              lastTouchpoint: new Date().toISOString(),
              followUpDate:
                stage === 'Interviewing'
                  ? new Date(Date.now() + 1000 * 60 * 60 * 24 * 2).toISOString()
                  : stage === 'Offer'
                  ? new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString()
                  : undefined,
            }
          : job,
      ),
    );

    setLocalTasks((prev) => {
      const generated: JobTask[] = [];
      if (stage === 'Interviewing') {
        generated.push({
          id: `task-${createId()}`,
          jobId,
          title: 'Automate interview prep kit (stories + metrics)',
          category: 'Preparation',
          dueDate: new Date(Date.now() + 1000 * 60 * 60 * 12).toISOString(),
          status: 'scheduled',
          autoGenerated: true,
        });
      }
      if (stage === 'Offer') {
        generated.push({
          id: `task-${createId()}`,
          jobId,
          title: 'Generate negotiation brief & market calibration',
          category: 'Research',
          dueDate: new Date(Date.now() + 1000 * 60 * 60 * 6).toISOString(),
          status: 'pending',
          autoGenerated: true,
        });
      }
      return [...prev, ...generated];
    });
  };

  const handleTaskStatus = (taskId: string, status: TaskStatus) => {
    if (isRemote) {
      updateTaskStatus.mutate({ taskId, status });
      return;
    }

    setLocalTasks((prev) => prev.map((task) => (task.id === taskId ? { ...task, status } : task)));
  };

  const handleScheduleFollowUp = (job: JobLead) => {
    if (isRemote) {
      scheduleFollowUp.mutate({ matchId: job.id, job });
      return;
    }

    const dueDate = new Date(Date.now() + 1000 * 60 * 60 * 24 * 2).toISOString();
    const newTask: JobTask = {
      id: `task-${createId()}`,
      jobId: job.id,
      title: `Follow up with ${job.company} about ${job.role}`,
      category: 'Follow-up',
      dueDate,
      status: 'scheduled',
      autoGenerated: true,
    };

    setLocalTasks((prev) => [newTask, ...prev]);
    setLocalJobs((prev) => prev.map((lead) => (lead.id === job.id ? { ...lead, followUpDate: dueDate } : lead)));
  };

  const handleGenerateWeeklyPlan = () => {
    if (isRemote) {
      console.warn('[plan] Implement Supabase automation generation.');
      return;
    }

    const planTasks: JobTask[] = jobs.flatMap((job) => {
      const tasksForJob: JobTask[] = [];
      if (job.stage === 'Prospecting') {
        tasksForJob.push({
          id: `task-${createId()}`,
          jobId: job.id,
          title: 'Spin up ICP research brief and outreach list',
          category: 'Research',
          dueDate: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(),
          status: 'pending',
          autoGenerated: true,
        });
      }
      if (job.stage === 'Applied') {
        tasksForJob.push({
          id: `task-${createId()}`,
          jobId: job.id,
          title: 'Draft recruiter follow-up & send via sequence',
          category: 'Outreach',
          dueDate: new Date(Date.now() + 1000 * 60 * 60 * 24 * 2).toISOString(),
          status: 'pending',
          autoGenerated: true,
        });
      }
      if (job.stage === 'Interviewing') {
        tasksForJob.push({
          id: `task-${createId()}`,
          jobId: job.id,
          title: 'Automate interview debrief template + story bank',
          category: 'Preparation',
          dueDate: new Date(Date.now() + 1000 * 60 * 60 * 24 * 3).toISOString(),
          status: 'scheduled',
          autoGenerated: true,
        });
      }
      return tasksForJob;
    });

    setLocalTasks((prev) => [...planTasks, ...prev]);
  };

  const handleAddJob = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const id = `lead-${createId()}`;
    const tags = newJob.tags
      .split(',')
      .map((tag) => tag.trim())
      .filter(Boolean);

    if (isRemote) {
      try {
        await addJobMutation.mutateAsync({
          company: newJob.company,
          role: newJob.role,
          location: newJob.location,
          link: newJob.link,
          priority: newJob.priority,
          tags: tags.length ? tags : ['Custom'],
        });
        await matchesQuery.refetch();
        setNewJob({ company: '', role: '', location: '', link: '', priority: 'Medium', tags: '' });
      } catch (error) {
        console.error('[addJob] failed to insert job', error);
      }
      return;
    }

    const job: JobLead = {
      id,
      company: newJob.company,
      role: newJob.role,
      location: newJob.location,
      link: newJob.link,
      priority: newJob.priority,
      stage: 'Prospecting',
      lastTouchpoint: new Date().toISOString(),
      automationScore: 60 + Math.floor(Math.random() * 20),
      tags: tags.length ? tags : ['Custom'],
      notes: ['Auto-create sequences & score leads'],
      description: '',
    };

    setLocalJobs((prev) => [job, ...prev]);
    setSelectedJobId(id);
    setNewJob({ company: '', role: '', location: '', link: '', priority: 'Medium', tags: '' });
  };

  const handleFilterChange = (key: keyof JobFilters, value: string) => {
    setFilters((prev) => ({ ...prev, [key]: value }));
  };

  const handleNewJobFieldChange = (field: keyof NewJobFormState, value: string) => {
    setNewJob((prev) => ({
      ...prev,
      [field]: field === 'priority' ? (value as JobPriority) : value,
    }));
  };

  // Early returns after all hooks are called
  if (supabaseEnabled) {
    if (authStatus === 'loading') {
      return (
        <div className="flex min-h-screen items-center justify-center bg-background text-muted-foreground">
          Preparing your workspace…
        </div>
      );
    }

    if (authStatus === 'signed-out') {
      return <AuthGate />;
    }
  }

  return (
    <div className="min-h-screen bg-background text-foreground">
      <div className="flex min-h-screen">
        <aside className="sticky top-0 hidden h-screen w-64 lg:block">
          <SidebarNavigation activeLabel="Matches" />
        </aside>

        <div className="flex flex-1 flex-col">
          <AppHeader
            filters={filters}
            filteredJobsCount={filteredJobs.length}
            activeTab={activeTab}
            isRemote={isRemote}
            user={user}
            onFilterChange={handleFilterChange}
            onTabChange={setActiveTab}
            onMobileNavToggle={() => setIsMobileNavOpen(true)}
            onSignOut={() => signOut().catch((error) => console.error('[auth] sign out failed', error))}
          />

          <main className="mx-auto w-full max-w-6xl flex-1 px-4 py-8 sm:px-6 lg:px-8">
            <div className="grid gap-8 lg:grid-cols-[320px_minmax(0,1fr)_320px]">
              <div className="space-y-6">
                <PipelineSidebar
                  filters={filters}
                  filteredJobs={filteredJobs}
                  selectedJobId={selectedJobId}
                  onSelectJob={(id) => setSelectedJobId(id)}
                  onFilterChange={handleFilterChange}
                  newJob={newJob}
                  onNewJobChange={handleNewJobFieldChange}
                  onSubmitNewJob={handleAddJob}
                />
              </div>
              <JobMatchesView
                filteredJobs={filteredJobs}
                selectedJob={selectedJob}
                sortBy={sortBy}
                filters={filters}
                isLoadingMatches={isLoadingMatches}
                isErrorMatches={isErrorMatches}
                onSelectJob={setSelectedJobId}
                onFilterChange={handleFilterChange}
                onSortChange={setSortBy}
                onGenerateWeeklyPlan={handleGenerateWeeklyPlan}
                onScheduleFollowUp={handleScheduleFollowUp}
              />

              <PipelineView
                selectedJob={selectedJob}
                jobTasks={jobTasks}
                nextFollowUps={nextFollowUps}
                pipelineMetrics={pipelineMetrics}
                automationIdeas={automationIdeas}
                outreachTemplates={outreachTemplates}
                jobs={jobs}
                isLoadingMatches={isLoadingMatches}
                onStageChange={handleStageChange}
                onScheduleFollowUp={handleScheduleFollowUp}
                onTaskStatusChange={handleTaskStatus}
              />
            </div>
          </main>
        </div>
      </div>

      {isMobileNavOpen ? (
        <div className="fixed inset-0 z-50 bg-black/40 backdrop-blur-sm lg:hidden" onClick={() => setIsMobileNavOpen(false)}>
          <div
            className="absolute bottom-0 left-0 right-0 max-h-[80vh] rounded-t-3xl border border-border/60 bg-background/95 p-6 shadow-soft-lg"
            onClick={(event) => event.stopPropagation()}
          >
            <div className="mb-4 flex items-center justify-between">
              <span className="text-sm font-semibold text-muted-foreground">Navigation</span>
              <button
                type="button"
                onClick={() => setIsMobileNavOpen(false)}
                className="rounded-full border border-border px-3 py-1 text-xs text-muted-foreground"
              >
                Close
              </button>
            </div>
            <div className="max-h-[60vh] overflow-y-auto">
              <SidebarNavigation activeLabel="Matches" />
            </div>
          </div>
        </div>
      ) : null}
    </div>
  );
};

export default JobSearchAutomation;
